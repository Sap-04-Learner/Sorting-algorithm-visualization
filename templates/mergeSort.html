{% extends "base.html" %} 
{% load static %} 

{% block title %}Merge Sort{%endblock title %} 
{% block merge %}active{% endblock merge %} 

{% block content %}

<h1 class="head">Merge Sort</h1>

<p class="para">
  Merge sort is one of the most efficient sorting algorithms. It works on the
  principle of Divide and Conquer based on the idea of breaking down a list into
  several sub-lists until each sub list consists of a single element and merging
  those sub lists in a manner that results into a sorted list. Merge sort is
  particularly beneficial when you need a stable sort. The time complexity of
  Merge Sort is O(nlogn). Merge sort is similar to the quick sort algorithm as
  it uses the divide and conquer approach to sort the elements. It is one of the
  most popular and efficient sorting algorithm.
</p>

<h3 class="sub-head">Characteristics of Merge Sort Algortihm</h3>

<ol class="para">
  <li class="list">
    <b>Divide and conquer:</b> Merge sort uses a divide and conquer approach,
    breaking down the problem into smaller subproblems and solving them
    individually.
  </li>
  <li class="list">
    <b>Recursive:</b> It employs recursion to sort the sub lists. The algorithm
    repeatedly divides the list until it reaches the base case of a single
    element, and then merges the sub lists back together.
  </li>
  <li class="list">
    <b>Stable soting:</b> Merge sort is a stable sorting algorithm, meaning that
    it preserves the relative order of equal elements in the sorted output.
  </li>
  <li class="list">
    <b>Time complexity:</b> Merge sort has a time complexity of O(n log n),
    making it efficient for large datasets.
  </li>
  <li class="list">
    <b>Space complexity:</b> Merge sort requires additional space to store the
    temporary sub lists during the merging process. Its space complexity is
    O(n).
  </li>
</ol>

<h3 class="sub-head">Animated Video Explaination and Code</h3>

<div class="video">
  <iframe width="720" height="400" src="https://www.youtube-nocookie.com/embed/bKT9yyRslm8?si=wQPwy-DcR1WSH4wU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

<p class="para">
  Through this video, it becomes very clear how merge sort works.
</p>

<div class="code">
  <div class="copy">
    <p>Copy Python Code</p>
    <div class="copy-btn"><i class="fas fa-copy"></i></div>
  </div>

  <pre>
        <code class="language-python">
def merge_sort(arr):
    if len(arr) > 1:
        # Finding the middle of the array
        mid = len(arr) // 2
                
        # Dividing the array into two halves
        left_half = arr[:mid]
        right_half = arr[mid:]
                
        # Recursively sorting the first half
        merge_sort(left_half)
                
        # Recursively sorting the second half
        merge_sort(right_half)
                
        # Merge the sorted halves
        i = j = k = 0
                
        # Copy data to temp arrays left_half[] and right_half[]
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1
                
        # Checking if any element was left
        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1
                
        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1
        
# Example usage:
arr = [12, 11, 13, 5, 6, 7]
print("Original array:", arr)
merge_sort(arr)
print("Sorted array is:", arr)        
        </code>
    </pre>
</div>

<div>
  <h3 class="sub-head">Time Complexity Graph</h3>
  <p class="para">
    This chart illustrates the time complexity of the Merge Sort 
    algorithm across different scenarios (best case, average case, 
    and worst case) as the input size increases.
  </p>

  <div class="graph">
      <form class="btn" action="{% url "viewMerge" %}" method="post">
          {% csrf_token %}
          <button id="startButton" type="submit" name="action" value="start">Start Plotting</button>
      </form>

      <div class="graph-axis para">
          <p class="y-axis">Time (s)</p>
      
          <div class="chart">
              <canvas id="myChart" width="400" height="400"></canvas>
          </div>
      </div>
      <p class="x-axis  para">Input Size (n)</p>
  </div>

</div>

<h3 class="sub-head">Advantages of Merge Sort</h3>

<ol class="para">
  <li class="list">
    <b>Stability:</b> Merge sort is a stable sorting algorithm, which means it
    preserves the relative order of equal elements. This is particularly useful
    when sorting objects with multiple keys or when maintaining the original
    order of equal elements is important.
  </li>
  <li class="list">
    <b>Adaptability:</b> Merge sort is adaptable and can be easily modified to
    work efficiently with different data structures, such as linked lists,
    arrays, and trees, making it versatile for various applications.
  </li>
  <li class="list">
    <b>Efficiency:</b> It has a time complexity of O(n log n), making it one of
    the most efficient sorting algorithms, particularly for large datasets.
  </li>
</ol>

<h3 class="sub-head">Disadvantages of Merge Sort</h3>

<ol class="para">
  <li class="list">
    <b>Space Complexity: </b>It requires additional memory proportional to the
    input size for the merge operation, making it less efficient in
    memory-constrained environments.
  </li>
  <li class="list">
    <b>Not Adaptive:</b> Merge sort's time complexity remains O(n log n)
    regardless of the input's initial order, making it less efficient than
    adaptive algorithms for partially sorted arrays or small sizes.
  </li>
  <li class="list">
    <b>Not In-Place:</b> Merge sort is not an in-place algorithm, requiring
    additional space for temporary arrays during sorting, which can be
    impractical for large arrays or constrained memory systems.
  </li>
</ol>

<h3 class="sub-head">Real Life Time Applications of Merge Sort Algorithms</h3>

<ol class="para">
  <li class="list">
    Sorting a large dataset of user information in a social media platform.
  </li>
  <li class="list">
    Organizing a huge library of books based on their titles or author names.
  </li>
  <li class="list">
    Sorting a list of products in an e-commerce platform based on their prices
    or ratings.
  </li>
  <li class="list">
    Arranging a dataset of student records in a school database based on their
    names, roll numbers, or grades.
  </li>
  <li class="list">
    Sorting a list of scientific research papers based on their publication date
    or citation count.
  </li>
</ol>

<p class="para">
  This algorithm is considered more efficient than other sorting algorithms,
  such as Bubble Sort and Insertion Sort, especially when working with large
  datasets.
</p>

{% endblock content %}

{% block script %}
<script type="text/javascript" src="{% static 'script_4.js' %}"></script>
{% endblock script %}
